# yaml-language-server: $schema=https://raw.githubusercontent.com/compose-spec/compose-spec/master/schema/compose-spec.json




services:
  mongodb:
    # ðŸ”¹ðŸ”¹ MongoDB ðŸ”¹ðŸ”¹
    image: docker.io/mongo
    container_name: mongodb
    hostname: ${MONGODB_HOSTNAME:-mongodb}
    extra_hosts:
      - host.docker.internal:host-gateway
    networks:
      - backend
      - publicnet
    expose:
      - 27017
    volumes:
      - ${CONFIG_PATH:-./volumes}/mongodb/data:/data/db
    labels:
      traefik.enable: true
      traefik.tcp.routers.mongodb.rule: HostSNI(`mongodb.$DOMAIN`) || HostSNI(`mongodb.$TS_HOSTNAME.$DOMAIN`)
      traefik.tcp.routers.mongodb.service: mongodb@docker
      traefik.tcp.routers.mongodb.tls.domains[0].main: $DOMAIN
      traefik.tcp.routers.mongodb.tls.domains[0].sans: "*.$DOMAIN,$TS_HOSTNAME.$DOMAIN"
      traefik.tcp.routers.mongodb.tls.passthrough: true
      traefik.tcp.services.mongodb.loadbalancer.server.port: 27017
      traefik.tcp.services.mongodb.loadbalancer.server.tls: true
    healthcheck:
      test: ["CMD-SHELL", "mongosh 127.0.0.1:27017/test --quiet --eval 'db.runCommand(\"ping\").ok' > /dev/null 2>&1 || exit 1"]
      interval: 10s
      timeout: 10s
      retries: 5
      start_period: 40s
    restart: always

  redis:
    # ðŸ”¹ðŸ”¹ Redis ðŸ”¹ðŸ”¹
    # NOTE: If you want to use Valkey (open source) instead of Redis (source available),
    # uncomment the Valkey statement and comment out the Redis statement.
    # Using Valkey with Firecrawl is untested and not guaranteed to work. Use with caution.
    image: docker.io/redis:alpine
    # image: valkey/valkey:alpine
    container_name: redis
    hostname: redis
    extra_hosts:
      - host.docker.internal:host-gateway
    networks:
      - backend
      - publicnet
    expose:
      - ${REDIS_PORT:-6379}
    ports:
      - ${REDIS_PORT:-6379}:${REDIS_PORT:-6379}
    volumes:
      - ${CONFIG_PATH:-./volumes}/redis:/data
    privileged: true  # for `sysctl vm.overcommit_memory=1` to work
    environment:
      REDIS_HOST: ${REDIS_HOSTNAME:-redis}
      REDIS_PORT: ${REDIS_PORT:-6379}
      REDIS_DATABASE: ${REDIS_DATABASE:-0}
      REDIS_USERNAME: ${REDIS_USERNAME:-default}
      REDIS_PASSWORD: ${REDIS_PASSWORD:-redis}
    #  REDIS_TLS_CERT_FILE: ${REDIS_TLS_CERT_FILE:-/data/redis.crt}
    #  REDIS_TLS_KEY_FILE: ${REDIS_TLS_KEY_FILE:-/data/redis.key}
    command:
      - sh
      - -c
      - |
        sysctl vm.overcommit_memory=1 &> /dev/null &&
        redis-server
        --appendonly yes
        --save 60 1
        --bind 0.0.0.0
        --port ${REDIS_PORT:-6379}
        --requirepass ${REDIS_PASSWORD:?}
    labels:
      traefik.enable: true
      traefik.tcp.routers.redis.rule: HostSNI(`redis.$DOMAIN`) || HostSNI(`redis.$TS_HOSTNAME.$DOMAIN`)
      traefik.tcp.routers.redis.service: redis@docker
      traefik.tcp.routers.redis.tls.domains[0].main: $DOMAIN
      traefik.tcp.routers.redis.tls.domains[0].sans: "*.$DOMAIN,$TS_HOSTNAME.$DOMAIN"
      traefik.tcp.routers.redis.tls.passthrough: true
      traefik.tcp.services.redis.loadbalancer.server.port: ${REDIS_PORT:-6379}
      traefik.tcp.services.redis.loadbalancer.server.tls: true
    logging:
      driver: "json-file"
      options:
        max-size: "1m"
        max-file: "1"
    healthcheck:
      test: ["CMD-SHELL", "redis-cli ping > /dev/null 2>&1 || exit 1"]
      interval: 10s
      timeout: 5s
    cpus: 0.5
    mem_reservation: 200M
    mem_limit: 4G
    restart: always
  searxng:
    # ðŸ”¹ðŸ”¹ SearxNG ðŸ”¹ðŸ”¹  # https://hub.docker.com/r/searxng/searxng
    # SearxNG is a privacy-respecting, hackable, open-source metasearch engine.
    image: docker.io/searxng/searxng
    container_name: searxng
    hostname: searxng
    extra_hosts:
      - host.docker.internal:host-gateway
    networks:
      - backend
      - publicnet
    volumes:
      # touch ${CONFIG_PATH:-./volumes}/searxng/limiter.toml
      - ${CONFIG_PATH:-./volumes}/searxng/config:/etc/searxng
      - ${CONFIG_PATH:-./volumes}/searxng/data:/var/cache/searxng
    environment:
      SEARXNG_BASE_URL: ${SEARXNG_INTERNAL_URL:-http://searxng:${SEARXNG_PORT:-8080}}
      SEARXNG_SECRET: ${SEARXNG_SECRET:?}
    logging:
      driver: "json-file"
      options:
        max-size: "1m"
        max-file: "1"
    labels:
      traefik.enable: true
      traefik.http.services.searxng.loadbalancer.server.port: ${SEARXNG_PORT:-8080}
      homepage.group: Search
      homepage.name: SearxNG
      homepage.icon: searxng.png
      homepage.href: https://searxng.$DOMAIN/
      homepage.description: Privacy-focused metasearch that aggregates results from many sources without tracking
      kuma.searxng.http.name: searxng.$TS_HOSTNAME.$DOMAIN
      kuma.searxng.http.url: https://searxng.$DOMAIN
      kuma.searxng.http.interval: 30
    healthcheck:
      test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://127.0.0.1:${SEARXNG_PORT:-8080}/ || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: always
  qdrant:
    # ðŸ”¹ðŸ”¹ Qdrant ðŸ”¹ðŸ”¹
    profiles:
      - extras
    image: qdrant/qdrant
    container_name: qdrant
    hostname: qdrant
    networks:
      - publicnet
    expose:
      - 6333
    volumes:
      - ${CONFIG_PATH:-./volumes}/qdrant/storage:/qdrant/storage
    environment:
      <<: *common-env
      QDRANT_STORAGE_PATH: /qdrant/storage
      QDRANT_STORAGE_TYPE: disk
      QDRANT_STORAGE_DISK_PATH: /qdrant/storage
      QDRANT_STORAGE_DISK_TYPE: disk
    labels:
      traefik.enable: true
      traefik.http.services.qdrant.loadbalancer.server.port: 6333
      homepage.group: AI
      homepage.name: Qdrant
      homepage.icon: qdrant.png
      homepage.href: https://qdrant.$DOMAIN
      homepage.description: Qdrant is a vector database for storing and querying vectors.
    restart: always
