user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
    multi_accept on;
}

http {
  include /etc/nginx/mime.types;
  default_type application/octet-stream;

  access_log /dev/stdout combined;
  error_log /dev/stderr warn;
  log_format main '$$remote_addr - $$remote_user [$$time_local] "$$request" '
                  '$$status $$body_bytes_sent "$$http_referer" '
                  '"$$http_user_agent" "$$http_x_forwarded_for" '
                  'auth_method="$$auth_method" original_uri="$$http_x_original_uri" '
                  'middleware="$$middleware_name"';
  limit_req_zone $$binary_remote_addr zone=auth:10m rate=20r/s;  # Rate limit zone used by `location /auth`
  limit_req_status 429;  # Optional: return 429 instead of default 503 so your 429 error_page is used
  access_log /var/log/nginx/access.log main;
  sendfile on;
  tcp_nopush on;
  tcp_nodelay on;
  keepalive_timeout 65;
  types_hash_max_size 2048;
  server_tokens off;
  map_hash_bucket_size 128;


  set_real_ip_from 10.0.0.0/8;
  set_real_ip_from 100.64.0.0/10;
  set_real_ip_from 127.0.0.0/8;
  set_real_ip_from 169.254.0.0/16;
  set_real_ip_from 172.16.0.0/12;
  set_real_ip_from 192.0.0.0/24;
  set_real_ip_from 192.0.2.0/24;
  set_real_ip_from 192.168.0.0/16;
  set_real_ip_from 198.18.0.0/15;
  set_real_ip_from 198.51.100.0/24;
  set_real_ip_from 203.0.113.0/24;
  set_real_ip_from 224.0.0.0/4;
  set_real_ip_from 240.0.0.0/4;
  set_real_ip_from 2002::/16;
  set_real_ip_from fc00::/7;
  set_real_ip_from fd00::/8;
  set_real_ip_from fe80::/10;
  set_real_ip_from ::1/128;
  real_ip_header X-Forwarded-For;
  real_ip_recursive on;
  geo $$ip_whitelisted {
    default 0;
    10.0.0.0/8           1;
    100.64.0.0/10        1;
    127.0.0.0/8          1;
    169.254.0.0/16       1;
    172.16.0.0/12        1;
    192.0.0.0/24         1;
    192.0.2.0/24         1;
    192.168.0.0/16       1;
    198.18.0.0/15        1;
    198.51.100.0/24      1;
    203.0.113.0/24       1;
    224.0.0.0/4          1;
    240.0.0.0/4          1;
    2002::/16            1;
    fc00::/7             1;
    fd00::/8             1;
    fe80::/10            1;
    ::1/128              1;
  }


  map $$http_x_api_key $$api_key_valid {
    default 0;
    "${NGINX_AUTH_API_KEY:?}" 1;
  }

  # Extract subdomain (e.g. "whoami" from whoami.${DOMAIN})
  map $$host $$subdomain {
    ~^(?<name>[^.]+)\.${DOMAIN}$ $$name;
    default "";
  }

  # Backends list
  map $$subdomain $$backend_list {
      default "";
      ~.+  "micklethefickle beatapostapita vractormania arnialtrashlid cloudserver1 cloudserver2 cloudserver3";
  }

  upstream tinyauth {
      server tinyauth:3000;
  }

  server {
    listen 80 default_server;
    server_name *.${DOMAIN};

    set $$auth_passed 0;
    set $$auth_method "none";
    set $$middleware_name "unknown";

    if ($$api_key_valid = 1) {
        set $$auth_passed 1;
        set $$auth_method "api_key";
    }

    if ($$ip_whitelisted = 1) {
        set $$auth_passed 1;
        set $$auth_method "ip_whitelist";
    }

    location /auth {
        set $$middleware_name "auth";
        limit_req zone=auth burst=20 nodelay;

        if ($$auth_passed = 1) {
            add_header X-Auth-Method "$$auth_method" always;
            add_header X-Auth-Passed "true" always;
            add_header X-Middleware-Name "$$middleware_name" always;
            return 200 "OK";
        }

        proxy_pass http://tinyauth/api/auth/traefik;
        proxy_pass_request_body off;
        proxy_set_header Content-Length "";
        proxy_set_header X-Original-URI $$http_x_original_uri;
        proxy_set_header X-Original-Method $$http_x_original_method;
        proxy_set_header X-Real-IP $$remote_addr;
        proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $$scheme;
        proxy_set_header X-Forwarded-Host $$http_x_forwarded_host;

        add_header X-Auth-Method "tinyauth" always;
        add_header X-Middleware-Name "$$middleware_name" always;

        access_log /var/log/nginx/auth.log main;
    }

    location /health {
        access_log off;
        return 200 "nginx auth service healthy\n";
        add_header Content-Type text/plain;
    }

    location /middlewares {
        access_log off;
        return 200 '{
            "available_middlewares": [
                {"path": "/auth", "description": "Standard auth (API key OR IP whitelist OR tinyauth)"}
            ],
            "usage": "Use traefik.http.routers.<service>.middlewares: nginx-auth@file"
        }';
        add_header Content-Type application/json;
    }

    location / {
      if ($$subdomain = "") {
        return 404 '{"error":"invalid host"}';
        add_header Content-Type application/json;
      }

      # Round-robin fallback logic
      set $$backend "";
      set $$i 0;

      # try backends in sequence until one works
      proxy_next_upstream error timeout invalid_header http_502 http_503 http_504;

      # feed subdomain + backend into proxy_pass
      proxy_pass https://$$subdomain.$$backend.${DOMAIN}$$request_uri;
      proxy_set_header Host $$subdomain.$$backend.${DOMAIN};
      proxy_set_header X-Real-IP $$remote_addr;
      proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $$scheme;
    }

    error_page 401 /401.html;
    error_page 403 /403.html;
    error_page 429 /429.html;
    
    location = /401.html {
        internal;
        return 401 '{"error": "Authentication required", "methods": ["api_key", "ip_whitelist", "tinyauth"]}';
        add_header Content-Type application/json;
    }
    
    location = /403.html {
        internal;
        return 403 '{"error": "Access Forbidden"}';
        add_header Content-Type application/json;
    }
  }
}