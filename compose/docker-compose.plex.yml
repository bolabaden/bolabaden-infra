secrets:
  plex-token:
    file: ${SECRETS_PATH:?}/plex-token.txt
  riven-api-key:
    file: ${SECRETS_PATH:?}/riven-api-key.txt
  jellyfin-api-key:
    file: ${SECRETS_PATH:?}/jellyfin-api-key.txt
  emby-api-key:
    file: ${SECRETS_PATH:?}/emby-api-key.txt
  realdebrid-api-key:
    file: ${SECRETS_PATH:?}/realdebrid-api-key.txt
  alldebrid-api-key:
    file: ${SECRETS_PATH:?}/alldebrid-api-key.txt
  torbox-api-key:
    file: ${SECRETS_PATH:?}/torbox-api-key.txt
  mdblist-api-key:
    file: ${SECRETS_PATH:?}/mdblist-api-key.txt
  listrr-api-key:
    file: ${SECRETS_PATH:?}/listrr-api-key.txt
  trakt-api-key:
    file: ${SECRETS_PATH:?}/trakt-api-key.txt
  jackett-api-key:
    file: ${SECRETS_PATH:?}/jackett-api-key.txt
  prowlarr-api-key:
    file: ${SECRETS_PATH:?}/prowlarr-api-key.txt
  orionoid-api-key:
    file: ${SECRETS_PATH:?}/orionoid-api-key.txt


configs:

  plex_update.sh:
    content: |
      #!/bin/bash
      # PLEX PARTIAL SCAN script or PLEX UPDATE script
      # When zurg detects changes, it can trigger this script IF your config.yml contains
      # on_library_update: sh plex_update.sh "$$@"
      # Modified from https://github.com/debridmediamanager/zurg-testing/blob/main/plex_update.sh
      token=${PLEX_TOKEN:-replace-me}

      # DON'T CHANGE ANYTHING AFTER THIS LINE
      plex_url="${PLEX_INTERNAL_URL:-http://plex:32400}"  # If you're using zurg inside a Docker container, by default it is 172.17.0.1:32400
      zurg_mount="${ZURG_MOUNT:-/mnt/remote/realdebrid}"  # Replace with your zurg mount path, ensure this is what Plex sees

      # Get the list of section IDs
      section_ids=$$(curl -sLX GET "$${plex_url}/library/sections" -H "X-Plex-Token: $${token}" | xmllint --xpath "//Directory/@key" - | sed 's/key="//g' | tr '"' '\n')
      for arg in "$$@"
      do
          modified_arg="$${zurg_mount}/$${arg}"
          encoded_arg=$$(echo -n "$${modified_arg}" | python3 -c "import sys, urllib.parse as ul; print (ul.quote_plus(sys.stdin.read()))")
          if [ -z "$${encoded_arg}" ]; then
              echo "Error: Encoded argument is empty. Check the input or encoding process."
              continue
          fi
          for section_id in $${section_ids}
          do
              final_url="$${plex_url}/library/sections/$${section_id}/refresh?path=$${encoded_arg}&X-Plex-Token=$${token}"
              echo "Encoded argument: $${encoded_arg}"
              echo "Section ID: $${section_id}"
              echo "Final URL: $${final_url}"
              curl -s "$${final_url}"
          done
      done
      echo "All updated sections refreshed"
      # credits to godver3
  homer-config.yml:
    content: |
      # Homepage configuration
      # See https://fontawesome.com/icons for icons options

      # Optional: Use external configuration file.
      # Using this will ignore remaining config in this file
      # externalConfig: https://${DOMAIN}/server-luci/config.yaml
      subtitle: "Welcome to ..."
      title: "${DOMAIN}"
      documentTitle: "${DOMAIN} - ${TS_HOSTNAME}" # Customize the browser tab text
      # Alternatively a fa icon can be provided:
      # icon: "fas fa-wand-magic-sparkles"
      #logo: https://elfhosted.com/images/logo.png
      header: true # Set to false to hide the header
      footer: Version 1.417.0
      columns: "auto" # "auto" or number (must be a factor of 12: 1, 2, 3, 4, 6, 12)
      connectivityCheck: false # whether you want to display a message when the apps are not accessible anymore (VPN disconnected for example)
      # Optional theming
      # theme: default # 'default' or one of the themes available in 'src/assets/themes'.
      # Optional custom stylesheet
      # Will load custom CSS files. Especially useful for custom icon sets.
      stylesheet:
        - "assets/custom.css"
      # Here is the exhaustive list of customization parameters
      # However all value are optional and will fallback to default if not set.
      # if you want to change only some of the colors, feel free to remove all unused key.
      colors:
        light:
          highlight-primary: "#222526"
          highlight-secondary: "#4285F4"
          highlight-hover: "#5A95F5"
          background: "#222526"
          card-background: "#FFFFFF"
          text: "#363636"
          text-header: "#FFFFFF"
          text-title: "#303030"
          text-subtitle: "#424242"
          card-shadow: "rgba(0, 0, 0, 0.1)"
          link-hover: "#363636"
          background-image: /assets/backgrounds/background-light.jpg
        dark:
          highlight-primary: "#222526"
          highlight-secondary: "#4285F4"
          highlight-hover: "#5A95F5"
          background: "#222526"
          card-background: "#2B2B2B"
          text: "#EAEAEA"
          text-header: "#FFFFFF"
          text-title: "#FAFAFA"
          text-subtitle: "#F5F5F5"
          card-shadow: "rgba(0, 0, 0, 0.4)"
          link-hover: "#FFDD57"
          background-image: /assets/backgrounds/background-dark.jpg
      # Optional message
      message:
        url: "https://homer.${DOMAIN}/assets/message/message.json"
        # mapping:
        #   content: 'message'
        #   style: 'style'
        #   title: 'title'
        refreshInterval: 10000
        icon: "fas fa-door-open"
      # Optional navbar
      # links: [] # Allows for navbar (dark mode, layout, and search) without any links
      links:
        - name: "Apps"
          icon: "fas fa-couch"
          url: "#config"
      # Services
      # First level array represents a group.
      # Leave only a "items" key if not using group (group name, icon & tagstyle are optional, section separation will not be displayed).
      services:
        - name: "Consume Media"
          icon: "fas fa-couch"
          # A path to an image can also be provided. Note that icon take precedence if both icon and logo are set.
          # logo: "path/to/logo"
          items:
            - name: "Plex"
              logo: "assets/png/plex.png"
              # Alternatively a fa icon can be provided:
              # icon: "fab fa-photo-video"
              subtitle: "Watch Movies/TV"
              tag: "public"
              tagstyle: "is-danger"
              url: "https://plex.${DOMAIN}"
              target: "_blank"  # Optional html tag target attribute
        - name: "Manage Media"
          icon: "fas fa-photo-video"
          items:
            - name: "Wizarr"
              icon: "fas fa-hat-wizard"
              subtitle: "Manage Plex / Emby / Jellyfin Accounts / Invites"
              tag: "public"
              tagstyle: "is-danger"
              url: "https://wizarr.${DOMAIN}"
              target: "_blank"  # Optional html tag target attribute
            - name: "Riven"
              icon: "fas fa-mountain"
              subtitle: "All-in-one Debrid Media Management"
              tag: "protected"
              tagstyle: "is-success"
              url: "https://riven.${DOMAIN}"
              target: "_blank"  # Optional html tag target attribute
            - name: "Riven (backend)"
              icon: "fas fa-mountain"
              subtitle: "Geek out over Riven's backend"
              tag: "protected"
              tagstyle: "is-success"
              url: "https://riven-backend.${DOMAIN}"
              target: "_blank"  # Optional html tag target attribute
        - name: "Download Media"
          icon: "fas fa-cloud-arrow-down"
          items:
            - name: "Zurg"
              logo: "assets/png/real-debrid.png"
              subtitle: "Manage RealDebrid Mount"
              tag: "protected"
              tagstyle: "is-success"
              url: "https://zurg.${DOMAIN}/http/"
              target: "_blank"  # Optional html tag target attribute
        - name: "Rclone"
          icon: "fas fa-truck"
          items:
            - name: "Rclone UI"
              logo: "assets/png/rclone.png"
              subtitle: "Rclone UI"
              tag: "protected"
              tagstyle: "is-success"
              url: "https://rclone.${DOMAIN}"
              target: "_blank"  # Optional html tag target attribute
  zurg-cli_debrid_update.sh:
    content: |
      #!/bin/bash
      webhook_url="http://cli-debrid:5000/webhook/rclone"  # Replace with your actual webhook URL
      # First notify our webhook for each file
      for arg in "$$@"
      do
          arg_clean=$$(echo "$$arg" | sed 's/\\//g')
          echo "Notifying webhook for: $$arg_clean"
          encoded_webhook_arg=$$(echo -n "$$arg_clean" | python3 -c "import sys, urllib.parse as ul; print(ul.quote(sys.stdin.read()))")
          curl -s -X GET "$$webhook_url?file=$$encoded_webhook_arg"
      done
      echo "Updates completed!"
  zurg-config.yml:
    content: |
      # Zurg configuration version
      zurg: v1

      # Get your token for the next line from https://real-debrid.com/apitoken
      token: "${REALDEBRID_TOKEN:?}"

      # additional download tokens - uncomment the lines below, and populate this with your additional tokens to auto-overcome bandwidth limitation issues
      download_tokens:
        - "${REALDEBRID_TOKEN_2}"

      # basic functionality
      host: "[::]" # do not change this if you are running it inside a docker container
      port: 9999 # do not change this if you are running it inside a docker container
      concurrent_workers: 32
      check_for_changes_every_secs: 30

      # misc configs
      retain_folder_name_extension: true # if true, zurg won't modify the filenames from real-debrid
      retain_rd_torrent_name: true # if true, it will strictly follow RD API torrent name property w/c should make this more compatible with rdt-client
      auto_delete_rar_torrents: false # if true, zurg will delete unstreamable rar files (these torrents will always be compressed in a rar archive no matter what files you select)
      use_download_cache: false # if true, during zurg initialization, it will fetch all downloads to unrestrict links faster

      enable_repair: true
      repair_every_mins: 60

      ###on_library_update: sh plex_update.sh "$$@"
      ignore_renames: true

      # do a RD speed test on every start
      cache_network_test_results: false

      # network configs
      network_buffer_size: 1048576 # 1 MiB
      serve_from_rclone: false
      verify_download_link: true # if true, zurg will check if the link is truly streamable; only relevant if serve_from_rclone is set to true (as it already does this all the time if serve_from_rclone is false)
      force_ipv6: false # force connect to real-debrid ipv6 addresses
      rate_limit_sleep_secs: 6 # wait time after getting a 429 from Real-Debrid API
      realdebrid_timeout_secs: 60 # api timeout
      retries_until_failed: 5 # api failures until considered failed
      get_torrents_count: 5000

      rar_action: extract

      addl_playable_extensions:
      - avi
      - flac
      - m4b
      - mkv
      - mp3
      - mp4

      # List of directory definitions and their filtering rules
      directories:
        audiobooks:
          group_order: 5
          group: media
          filters:
            - and:
              - is_music: true
              - media_info_duration_gte: 600

        music:
          group_order: 10
          group: media
          filters:
            - is_music: true

        anime:
          group_order: 15
          group: media
          filters:
            - regex: /\b[a-fA-F0-9]{8}\b/
            - any_file_inside_regex: /\b[a-fA-F0-9]{8}\b/

        shows:
          group_order: 20
          group: media
          filters:
            - has_episodes: true

        movies:
          group_order: 25
          group: media
          only_show_the_biggest_file: true
          filters:
            - regex: /.*/

      restrict_repair_to_cached: true
  zurg-setup.sh:
    content: |
      #!/bin/bash
      # Disable native auth (we do it with traefik instead when necessary)
      sed -i  "s/^username:/#username/" /config/config.yml
      sed -i  "s/^password:/#password/" /config/config.yml
      # Socks via WARP
      # # Enable proxy only if gluetun vars are not present
      # if [[ ! -z "$$ZURG_WARP_ENABLED" ]]; then
      #   echo "not enabling warp, we may no longer need it"
      #   # grep proxy /config/config.yml || echo 'proxy: socks5://127.0.0.1:1080' >> /config/config.yml
      #   # sed -i  "s/^#proxy:/proxy/" /config/config.yml
      # else
      #   # remove proxy if found
      #   sed -i  "s/^proxy:/#proxy/" /config/config.yml
      # fi
      # revert to repairing every hour
      grep repair_every_mins /config/config.yml \
        || echo 'repair_every_mins: 60' >> /config/config.yml
      # Enable rar extraction if it's not already there
      grep rar_action /config/config.yml || echo 'rar_action: extract' >> /config/config.yml
      # Check for changes every 10 sec - this is too aggressive on large libraries
      # sed -i  "s/check_for_changes_every_secs:.*/check_for_changes_every_secs: 10/" /config/config.yml
      # don't repair uncached
      grep restrict_repair_to_cached /config/config.yml \
        || echo 'restrict_repair_to_cached: true' >> /config/config.yml
      # # Don't serve from rclone - leave this up to the user now
      # sed -i  "s/serve_from_rclone:.*/serve_from_rclone: false/" /config/config.yml
      # Disable plex_update.sh unless user uses plexdebrid
        # we don't need the script
        sed -i  "s/on_library_update/#on_library_update/" /config/config.yml
      # Enable repair everywhere
      # disabled on 13 nov 2024 to debug
      # sed -i  "s/enable_repair:.*/enable_repair: true/" /config/config.yml
  plex-Preferences.xml:
    content: |
      <?xml version="1.0" encoding="utf-8"?>
      <Preferences
        AcceptedEULA="1"
        AnonymousMachineIdentifier="a02f47cd-9111-41fb-837d-dc6be25ba6d3"
        CertificateUUID="56d3167058f948448c4564df78239440"
        CertificateVersion="3"
        customConnections="https://plex.$DOMAIN:443"
        DlnaEnabled="1"
        FriendlyName="$DOMAIN"
        GlobalMusicVideoPathMigrated="1"
        LanguageInCloud="1"
        LastAutomaticMappedPort="0"
        MachineIdentifier="a36c4347-359e-408a-93a4-04948a773c57"
        ManualPortMappingMode="1"
        MergedRecentlyAdded="0"
        MetricsEpoch="1"
        OldestPreviousVersion="legacy"
        PlexOnlineHome="1"
        PlexOnlineMail="${PLEX_EMAIL:-boden.crouch@gmail.com}"
        PlexOnlineToken="${PLEX_API_KEY:-tzn6xvA4d8ygGXyR4sND}"
        PlexOnlineUsername="${PLEX_USERNAME:-brunner56}"
        ProcessedMachineIdentifier="${PLEX_MACHINE_IDENTIFIER:-508f1e66f9ebdecae95ab71afb36f051aed8bccc}"
        PublishServerOnPlexOnlineKey="1"
        ScheduledLibraryUpdateInterval="86400"
        ScheduledLibraryUpdatesEnabled="1"
        TranscoderTempDirectory="/transcode"/>
  #######################################################################################
  # RcloneFM Configuration
  #######################################################################################
  rclone-rclone.conf:
    content: |
      [rdhttp]
      type = http
      url = https://my.real-debrid.com/${REALDEBRID_WEBDAV_PASSWORD}/
      no_head = false
      no_slash = false

      [rdwebdav]
      type = webdav
      url = https://dav.real-debrid.com/
      vendor = other
      user = ${REALDEBRID_USER:-brunner56}
      pass = ${REALDEBRID_RCLONE_OBSCURE_PASS}

      [rdhttp2]
      type = http
      url = https://my.real-debrid.com/${REALDEBRID_WEBDAV_PASSWORD_2}/
      no_head = false
      no_slash = false

      [rdwebdav2]
      type = webdav
      url = https://dav.real-debrid.com/
      vendor = other
      user = ${REALDEBRID_USER2}
      pass = ${REALDEBRID_RCLONE_OBSCURE_PASS_2}

      [zurg]
      type = webdav
      url = http://zurg:9999/dav
      vendor = other
      pacer_min_sleep = 0

      [zurghttp]
      type = http
      url = http://zurg:9999/http/
      no_head = false
      no_slash = false

      [zurg-remote]
      type = webdav
      url = https://zurg.$DOMAIN/dav
      vendor = other
      pacer_min_sleep = 0

      [zurghttp-remote]
      type = http
      url = https://zurg.$DOMAIN/http/
      no_head = false
      no_slash = false

      [plex]
      type = webdav
      url = https://plex.$DOMAIN/
      vendor = other
      user = ${PLEX_USERNAME}
  realdebrid-account-monitor-main.py:
    content: |
      import requests
      import schedule
      import time
      import datetime
      import os
      import logging
      from dotenv import load_dotenv
      from croniter import croniter
      import pytz
      import re

      # Configuration
      load_dotenv()

      TOKENS = eval(os.getenv("TOKENS", "[]"))
      BASE_API = "https://api.real-debrid.com/rest/1.0"
      ENDPOINTS = {"traffic": "/traffic/details", "user": "/user"}
      INTERVAL_HOURS = int(os.getenv("INTERVAL_HOURS", 1))
      INTERVAL_SECONDS = int(os.getenv("INTERVAL_SECONDS", 0))
      CRON_SCHEDULE = os.getenv("CRON_SCHEDULE", None)
      REALDEBRID_TIMEZONE_STRING = "Europe/Paris"
      CRONTAB_TIMEZONE_STRING = os.getenv("TZ", "UTC")
      # Set up logging
      logging.basicConfig(
          level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
      )
      logger = logging.getLogger(__name__)

      # time.tzset() # ensure croniter uses the correct timezone
      # use Europe/Paris as the default timezone as Real-Debrid is based in France
      crontab_timezone = pytz.timezone(CRONTAB_TIMEZONE_STRING)
      realdebrid_timezone = pytz.timezone(REALDEBRID_TIMEZONE_STRING)


      # set up a file to write datapoints to for traffic
      TRAFFIC_FILE_PATH = os.getenv("TRAFFIC_FILE_PATH", os.path.join("data", "traffic_data.csv"))
      if not os.path.exists(TRAFFIC_FILE_PATH):
          os.makedirs(os.path.dirname(TRAFFIC_FILE_PATH), exist_ok=True)
          with open(TRAFFIC_FILE_PATH, "w") as f:
              f.write("username,datetime,traffic\n")


      def sanitised_token(token):
          # simply replace all but the first character and last 5 characters with *
          return token[0] + "*" * (len(token) - 6) + token[-5:]


      def format_bytes(bytes):
          for unit in ["B", "KB", "MB", "GB", "TB"]:
              if bytes < 1024:
                  return f"{bytes:.2f} {unit}"
              bytes /= 1024
          return f"{bytes:.2f} PB"


      def format_seconds(seconds):
          # format seconds into a string like "date (x days from now)"
          if seconds < 0:
              return "Expired"
          elif seconds < 60:
              return f"{seconds} seconds"
          elif seconds < 3600:
              return f"{seconds // 60} minutes"
          elif seconds < 86400:
              return f"{seconds // 3600} hours"
          elif seconds < 2592000:
              return f"{seconds // 86400} days"
          elif seconds < 31536000:
              # return x months, y days
              months = seconds // 2592000
              days = (seconds % 2592000) // 86400
              return f"{months} months, {days} days"
          else:
              # return x years, y months
              years = seconds // 31536000
              months = (seconds % 31536000) // 2592000
              return f"{years} years, {months} months"


      def get_traffic(token):
          today = datetime.datetime.now(realdebrid_timezone).strftime("%Y-%m-%d")
          params = {
              "start": today,
          }
          try:
              response = requests.get(
                  f"{BASE_API}{ENDPOINTS['traffic']}",
                  params=params,
                  headers={"Authorization": f"Bearer {token}"},
              )
              data = response.json()
          except Exception as e:
              logger.error(f"Failed to get traffic data for {sanitised_token(token)}: {e}")
              return None
          if response.status_code == 200:
              if today in data:
                  traffic_bytes = data[today]["bytes"]
                  return traffic_bytes
              elif data == []:
                  return 0
              else:
                  return None
          else:
              error, error_code = data.get("error", "Unknown error"), data.get("error_code", "Unknown error code")
              logger.error(
                  f"Failed to get traffic data for {sanitised_token(token)}: {response.status_code} - {error} ({error_code}) "
              )
              return None


      def get_user_details(token):
          try:
              response = requests.get(
                  f"{BASE_API}{ENDPOINTS['user']}",
                  headers={"Authorization": f"Bearer {token}"},
              )
              data = response.json()
          except Exception as e:
              logger.error(f"Failed to get user details for {sanitised_token(token)}: {e}")
              return None
          if response.status_code != 200:
              error, error_code = data.get("error", "Unknown error"), data.get("error_code", "Unknown error code")
              logger.error(
                  f"Failed to get user details for {sanitised_token(token)}: {error} ({error_code})"
              )
              return None
          return data


      def get_account_data():
          if len(TOKENS) == 0:
              logger.error("No tokens found in configuration")
              return
          lines = [""]
          logger.info("Checking account data for {} tokens...".format(len(TOKENS)))
          for token in TOKENS:
              user = get_user_details(token)
              if user is None:
                  continue
              premium = user["type"] == "premium"
              if not premium:
                  logger.error(f"Token {sanitised_token(token)} is not a premium account")
                  continue
              # 'premium' is seconds that the account is premium for
              expires_in = user["premium"]
              expiry_date = user["expiration"].split("T")[0]
              traffic = get_traffic(token)
              if traffic is None:
                  continue
              # write the traffic data to a file
              with open(TRAFFIC_FILE_PATH, "a") as f:
                  f.write(f"{user['username']},{datetime.datetime.now(realdebrid_timezone)},{traffic}\n")

              lines.append(f" {user['username']}: ")
              lines.append(f"  ├─ Type: {user["type"].capitalize()}")
              if premium:
                  lines.append(
                      f"  ├─ Premium until: {expiry_date} | {format_seconds(expires_in)} from now"
                  )
              lines.append(f"  ├─ Traffic today: {format_bytes(traffic)}")
              lines.append(f"  └─ Fidelity Points: {user['points']:,}")
              lines.append("")


              time.sleep(0.5)

          return lines

      def generate_traffic_summary():
          with open(TRAFFIC_FILE_PATH, "r") as f:
              lines = f.readlines()
          traffic_data = {}
          user_last_traffic = {}

          current_date = datetime.datetime.now(realdebrid_timezone).strftime("%Y-%m-%d")
          for line in lines[1:]:
              username, datetime_str, traffic = line.strip().split(",")
              date_str, time_str = datetime_str.split(" ")
              
              if date_str == current_date:
                  realdebrid_datetime = datetime.datetime.fromisoformat(datetime_str)
                  crontab_datetime = realdebrid_datetime.astimezone(crontab_timezone)
                  hour = crontab_datetime.strftime("%H")
                  traffic_value = float(traffic.split(" ")[0])
                  
                  # Calculate hourly traffic per user
                  if username in user_last_traffic:
                      hour_traffic = max(0, traffic_value - user_last_traffic[username])
                  else:
                      hour_traffic = traffic_value  # First occurrence, take as initial traffic
                  
                  # Update hourly traffic sum
                  traffic_data[hour] = traffic_data.get(hour, 0) + hour_traffic
                  
                  # Store last recorded traffic for this user
                  user_last_traffic[username] = traffic_value

          # Prepare output log
          lines = [""]
          total_traffic = 0
          lines.append("      Traffic Summary:")
          for hour in sorted(traffic_data.keys()):
              traffic = traffic_data[hour]
              total_traffic += traffic
              lines.append(f"         ├─ {hour}:00 - {format_bytes(traffic)}")
          lines.append(f"         └─ Total Today: {format_bytes(total_traffic)}")
          lines.append("")
          return lines

      def print_account_summaries():
          lines = [""]
          lines.extend(
              [
                  "=" * 60,
                  f"Real Debrid Account Summary - {datetime.datetime.now(crontab_timezone).strftime("%H:%M")}".center(60),
                  "=" * 60,
                  "",
              ]
          )
          lines.extend(get_account_data())
          lines.extend(generate_traffic_summary())
          lines.append("=" * 60)
          lines.append("")
          logger.info("\n".join(lines))

      if not CRON_SCHEDULE:
          if INTERVAL_HOURS:
              schedule.every(INTERVAL_HOURS).hours.do(print_account_data)
          elif INTERVAL_SECONDS:
              schedule.every(INTERVAL_SECONDS).seconds.do(print_account_data)


      if __name__ == "__main__":
          if CRON_SCHEDULE:
              base_time = datetime.datetime.now(crontab_timezone)
              cron = croniter(CRON_SCHEDULE, base_time)
              while True:
                  next_run = cron.get_next(datetime.datetime)
                  logger.info(f"Next run scheduled for {next_run} {CRONTAB_TIMEZONE_STRING}")
                  sleep_duration = (next_run - datetime.datetime.now(crontab_timezone)).total_seconds()
                  if sleep_duration > 0:
                      time.sleep(sleep_duration)
                  print_account_summaries()
                  base_time = next_run
                  cron = croniter(CRON_SCHEDULE, base_time) 

          while not CRON_SCHEDULE and (INTERVAL_HOURS or INTERVAL_SECONDS):
              schedule.run_pending()
              time.sleep(1)

  riven-frontend-server.json:
    content: |
      {
        "backendUrl": "http://riven:8080",
        "apiKey": "3e0be750b16ff363727d05d18ba364fd"
      }

services:
  riven-frontend:
    depends_on:
      riven:
        condition: service_healthy
    image: 'spoked/riven-frontend:latest'
    container_name: riven-frontend
    hostname: riven-frontend
    extra_hosts:
      - 'host.docker.internal:host-gateway'
    networks:
      - publicnet
    configs:
      - source: riven-frontend-server.json
        target: /riven/config/server.json
        mode: 0777
    tty: true
    labels:
      traefik.enable: "true"
      traefik.docker.network: "bridge"
      traefik.http.routers.riven-frontend.rule: 'Host(`riven.${DOMAIN}`) || Host(`riven.${TS_HOSTNAME}.${DOMAIN}`)'
      traefik.http.services.riven-frontend.loadbalancer.server.port: 3000
      homepage.group: 'Media Management'
      homepage.name: Riven
      homepage.icon: riven.png
      homepage.href: 'https://riven.$DOMAIN/'
      homepage.description: 'Modern frontend for Plex Debrid'
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://127.0.0.1:3000 || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: always
  riven:
    depends_on:
      riven-db:
        condition: service_healthy
    image: 'docker.io/spoked/riven:latest'
    container_name: riven
    hostname: riven
    extra_hosts:
      - 'host.docker.internal:host-gateway'
    networks:
      publicnet: {}
      warp-nat-net:
        gw_priority: 1
    secrets:
      - plex-token
      - riven-api-key
      - jellyfin-api-key
      - emby-api-key
      - realdebrid-api-key
      - alldebrid-api-key
      - torbox-api-key
      - mdblist-api-key
      - listrr-api-key
      - trakt-api-key
      - jackett-api-key
      - prowlarr-api-key
      - orionoid-api-key
    tty: true
    volumes:
      - '${CONFIG_PATH:-./configs}/riven/data:/riven/data'
      - '${ZURG_MOUNT_PATH:-/mnt/remote/zurg}:${ZURG_MOUNT_PATH:-/mnt/remote/zurg}:rshared'
      - '/mnt/symlinks:/mnt/symlinks'
    environment:
      - 'TZ=${TZ:-America/Chicago}'
      - DIALECT=postgres
      - 'RIVEN_DATABASE_HOST=postgresql+psycopg2://postgres:postgres@riven-db:5432/riven'
      - RIVEN_FORCE_ENV=true
      - SETTINGS_FILENAME=settings.json
      - SKIP_TRAKT_CACHE=false
      - HARD_RESET=false
      - REPAIR_SYMLINKS=false
      - API_KEY_FILE=/run/secrets/riven-api-key
      - TRAKT_API_CLIENT_ID=
      - SYMLINK_MAX_WORKERS=2
      - RIVEN_VERSION=0.21.21
      - RIVEN_DEBUG=false
      - RIVEN_LOG=true
      - RIVEN_FORCE_REFRESH=false
      - RIVEN_MAP_METADATA=true
      - RIVEN_TRACEMALLOC=false
      - 'RIVEN_SYMLINK_RCLONE_PATH=${RIVEN_SYMLINK_RCLONE_PATH:-${ZURG_MOUNT_PATH:-/mnt/remote/zurg}/__all__}'
      - RIVEN_SYMLINK_LIBRARY_PATH=/mnt/symlinks
      - RIVEN_SYMLINK_SEPARATE_ANIME_DIRS=true
      - RIVEN_SYMLINK_REPAIR_SYMLINKS=true
      - RIVEN_SYMLINK_REPAIR_INTERVAL=6.0
      - RIVEN_UPDATER_INTERVAL=120
      - RIVEN_UPDATERS_PLEX_TOKEN_FILE=/run/secrets/plex-token
      - RIVEN_PLEX_TOKEN_FILE=/run/secrets/plex-token
      - RIVEN_PLEX_ENABLED=true
      - RIVEN_UPDATERS_PLEX_ENABLED=true
      - 'RIVEN_PLEX_URL=${PLEX_INTERNAL_URL:-http://plex:32400}'
      - RIVEN_JELLYFIN_ENABLED=false
      - RIVEN_JELLYFIN_API_KEY_FILE=/run/secrets/jellyfin-api-key
      - 'RIVEN_JELLYFIN_URL=${JELLYFIN_INTERNAL_URL:-http://jellyfin:8096}'
      - RIVEN_EMBY_ENABLED=false
      - RIVEN_EMBY_API_KEY_FILE=/run/secrets/emby-api-key
      - 'RIVEN_EMBY_URL=${EMBY_INTERNAL_URL:-http://emby:8096}'
      - 'RIVEN_DOWNLOADERS_VIDEO_EXTENSIONS=["avi","mkv","mp4"]'
      - RIVEN_DOWNLOADERS_PROXY_URL=
      - RIVEN_DOWNLOADERS_REAL_DEBRID_ENABLED=true
      - RIVEN_DOWNLOADERS_REAL_DEBRID_API_KEY_FILE=/run/secrets/realdebrid-api-key
      - RIVEN_DOWNLOADERS_ALL_DEBRID_ENABLED=true
      - RIVEN_DOWNLOADERS_ALL_DEBRID_API_KEY_FILE=/run/secrets/alldebrid-api-key
      - RIVEN_DOWNLOADERS_TORBOX_ENABLED=false
      - RIVEN_DOWNLOADERS_TORBOX_API_KEY_FILE=/run/secrets/torbox-api-key
      - RIVEN_CONTENT_OVERSEERR_ENABLED=true
      - 'RIVEN_CONTENT_OVERSEERR_URL=${OVERSEERR_INTERNAL_URL:-http://overseerr:5055}'
      - 'RIVEN_CONTENT_OVERSEERR_API_KEY=${OVERSEERR_API_KEY}'
      - RIVEN_CONTENT_OVERSEERR_USE_WEBHOOK=false
      - RIVEN_CONTENT_OVERSEERR_UPDATE_INTERVAL=30
      - RIVEN_CONTENT_PLEX_WATCHLIST_ENABLED=true
      - 'RIVEN_CONTENT_PLEX_WATCHLIST_RSS=${RIVEN_CONTENT_PLEX_WATCHLIST_RSS:-[]}'
      - RIVEN_CONTENT_PLEX_WATCHLIST_UPDATE_INTERVAL=60
      - RIVEN_CONTENT_MDBLIST_ENABLED=false
      - RIVEN_CONTENT_MDBLIST_API_KEY_FILE=/run/secrets/mdblist-api-key
      - RIVEN_CONTENT_MDBLIST_UPDATE_INTERVAL=300
      - 'RIVEN_CONTENT_MDBLIST_LISTS=[]'
      - RIVEN_CONTENT_LISTRR_ENABLED=false
      - RIVEN_CONTENT_LISTRR_API_KEY_FILE=/run/secrets/listrr-api-key
      - RIVEN_CONTENT_LISTRR_UPDATE_INTERVAL=300
      - 'RIVEN_CONTENT_LISTRR_MOVIE_LISTS=[]'
      - 'RIVEN_CONTENT_LISTRR_SHOW_LISTS=[]'
      - RIVEN_CONTENT_TRAKT_ENABLED=true
      - RIVEN_CONTENT_TRAKT_API_KEY_FILE=/run/secrets/trakt-api-key
      - RIVEN_CONTENT_TRAKT_UPDATE_INTERVAL=3600
      - RIVEN_SCRAPING_AFTER_2=2
      - RIVEN_SCRAPING_AFTER_5=6
      - RIVEN_SCRAPING_AFTER_10=24
      - RIVEN_SCRAPING_PARSE_DEBUG=false
      - RIVEN_SCRAPING_ENABLE_ALIASES=true
      - RIVEN_SCRAPING_TORRENTIO_ENABLED=true
      - 'RIVEN_SCRAPING_TORRENTIO_FILTER=sort=qualitysize%7Cqualityfilter=480p,scr,cam,unknown'
      - 'RIVEN_SCRAPING_TORRENTIO_URL=${TORRENTIO_URL:-https://torrentio.strem.fun}'
      - RIVEN_SCRAPING_TORRENTIO_TIMEOUT=30
      - RIVEN_SCRAPING_TORRENTIO_RATELIMIT=true
      - RIVEN_SCRAPING_TORRENTIO_PROXY_URL=
      - RIVEN_SCRAPING_KNIGHTCRAWLER_ENABLED=true
      - 'RIVEN_SCRAPING_KNIGHTCRAWLER_FILTER=sort=qualitysize%7Cqualityfilter=480p,scr,cam,unknown'
      - 'RIVEN_SCRAPING_KNIGHTCRAWLER_URL=${KNIGHTCRAWLER_URL:-https://knightcrawler.elfhosted.com}'
      - RIVEN_SCRAPING_KNIGHTCRAWLER_TIMEOUT=30
      - 'RIVEN_SCRAPING_KNIGHTCRAWLER_RATELIMIT=${KNIGHTCRAWLER_RATELIMIT:-true}'
      - RIVEN_SCRAPING_JACKETT_ENABLED=true
      - 'RIVEN_SCRAPING_JACKETT_URL=${JACKETT_INTERNAL_URL:-http://jackett:9117}'
      - RIVEN_SCRAPING_JACKETT_API_KEY_FILE=/run/secrets/jackett-api-key
      - RIVEN_SCRAPING_JACKETT_TIMEOUT=10
      - RIVEN_SCRAPING_JACKETT_RATELIMIT=true
      - RIVEN_SCRAPING_PROWLARR_ENABLED=false
      - 'RIVEN_SCRAPING_PROWLARR_URL=${PROWLARR_INTERNAL_URL:-http://prowlarr:9696}'
      - RIVEN_SCRAPING_PROWLARR_API_KEY_FILE=/run/secrets/prowlarr-api-key
      - RIVEN_SCRAPING_PROWLARR_TIMEOUT=10
      - RIVEN_SCRAPING_PROWLARR_RATELIMIT=true
      - RIVEN_SCRAPING_PROWLARR_LIMITER_SECONDS=60
      - RIVEN_SCRAPING_ORIONOID_ENABLED=false
      - RIVEN_SCRAPING_ORIONOID_API_KEY_FILE=/run/secrets/orionoid-api-key
      - RIVEN_SCRAPING_ORIONOID_CACHED_RESULTS_ONLY=true
      - RIVEN_SCRAPING_ORIONOID_PARAMETERS_VIDEO3D=false
      - RIVEN_SCRAPING_ORIONOID_PARAMETERS_VIDEOQUALITY=sd_hd8k
      - RIVEN_SCRAPING_ORIONOID_PARAMETERS_LIMITCOUNT=5
      - RIVEN_SCRAPING_ORIONOID_TIMEOUT=10
      - RIVEN_SCRAPING_ORIONOID_RATELIMIT=true
      - RIVEN_SCRAPING_MEDIAFUSION_ENABLED=true
      - 'RIVEN_SCRAPING_MEDIAFUSION_URL=${MEDIAFUSION_INTERNAL_URL:-http://mediafusion:8000}'
      - RIVEN_SCRAPING_MEDIAFUSION_TIMEOUT=10
      - 'RIVEN_SCRAPING_MEDIAFUSION_RATELIMIT=${MEDIAFUSION_RATELIMIT:-false}'
      - 'RIVEN_SCRAPING_MEDIAFUSION_CATALOGS=prowlarr_streams,torrentio_streams'
      - RIVEN_SCRAPING_ZILEAN_ENABLED=true
      - 'RIVEN_SCRAPING_ZILEAN_URL=${ZILEAN_URL:-http://zilean.elfhosted.com}'
      - RIVEN_SCRAPING_ZILEAN_TIMEOUT=30
      - 'RIVEN_SCRAPING_ZILEAN_RATELIMIT=${MEDIAFUSION_RATELIMIT:-false}'
      - RIVEN_SCRAPING_COMET_ENABLED=true
      - 'RIVEN_SCRAPING_COMET_URL=http://comet:${COMET_PORT:-2020}'
      - 'RIVEN_SCRAPING_COMET_INDEXERS=${COMET_INDEXERS:-animetosho,anirena,eztv,limetorrents,nyaasi,solidtorrents,thepiratebay,torlock,yts}'
      - RIVEN_SCRAPING_COMET_TIMEOUT=30
      - 'RIVEN_SCRAPING_COMET_RATELIMIT=${COMET_RATELIMIT:-false}'
      - RIVEN_RANKING_PROFILE=default
      - 'RIVEN_RANKING_REQUIRE=[]'
      - 'RIVEN_RANKING_EXCLUDE=[]'
      - 'RIVEN_RANKING_PREFERRED=[]'
      - RIVEN_RANKING_RESOLUTIONS_2160P=false
      - RIVEN_RANKING_RESOLUTIONS_1080P=true
      - RIVEN_RANKING_RESOLUTIONS_720P=true
      - RIVEN_RANKING_RESOLUTIONS_480P=false
      - RIVEN_RANKING_RESOLUTIONS_360P=false
      - RIVEN_RANKING_RESOLUTIONS_UNKNOWN=true
      - RIVEN_RANKING_OPTIONS_TITLE_SIMILARITY=0.85
      - RIVEN_RANKING_OPTIONS_REMOVE_ALL_TRASH=true
      - RIVEN_RANKING_OPTIONS_REMOVE_RANKS_UNDER=-10000
      - RIVEN_RANKING_OPTIONS_REMOVE_UNKNOWN_LANGUAGES=false
      - RIVEN_RANKING_OPTIONS_ALLOW_ENGLISH_IN_LANGUAGES=true
      - 'RIVEN_RANKING_LANGUAGES_REQUIRED=["en"]'
      - 'RIVEN_RANKING_LANGUAGES_EXCLUDE=[]'
      - 'RIVEN_RANKING_LANGUAGES_PREFERRED=["en"]'
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_AV1_FETCH=false
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_AV1_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_AV1_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_AVC_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_AVC_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_AVC_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_BLURAY_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_BLURAY_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_BLURAY_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_DVD_FETCH=false
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_DVD_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_DVD_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_HDTV_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_HDTV_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_HDTV_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_HEVC_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_HEVC_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_HEVC_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_MPEG_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_MPEG_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_MPEG_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_REMUX_FETCH=false
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_REMUX_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_REMUX_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_VHS_FETCH=false
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_VHS_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_VHS_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_WEB_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_WEB_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_WEB_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_WEBDL_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_WEBDL_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_WEBDL_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_WEBMUX_FETCH=false
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_WEBMUX_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_WEBMUX_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_XVID_FETCH=false
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_XVID_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_QUALITY_XVID_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_BDRIP_FETCH=false
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_BDRIP_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_BDRIP_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_BRRIP_FETCH=false
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_BRRIP_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_BRRIP_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_DVDRIP_FETCH=false
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_DVDRIP_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_DVDRIP_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_HDRIP_FETCH=false
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_HDRIP_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_HDRIP_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_PPVRIP_FETCH=false
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_PPVRIP_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_PPVRIP_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_SATRIP_FETCH=false
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_SATRIP_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_SATRIP_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_TVRIP_FETCH=false
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_TVRIP_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_TVRIP_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_UHDRIP_FETCH=false
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_UHDRIP_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_UHDRIP_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_VHSRIP_FETCH=false
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_VHSRIP_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_VHSRIP_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_WEBDLRIP_FETCH=false
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_WEBDLRIP_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_WEBDLRIP_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_WEBRIP_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_WEBRIP_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_RIPS_WEBRIP_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_HDR_10BIT_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_HDR_10BIT_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_HDR_10BIT_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_HDR_DOLBY_VISION_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_HDR_DOLBY_VISION_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_HDR_DOLBY_VISION_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_HDR_HDR_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_HDR_HDR_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_HDR_HDR_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_HDR_HDR10PLUS_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_HDR_HDR10PLUS_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_HDR_HDR10PLUS_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_HDR_SDR_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_HDR_SDR_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_HDR_SDR_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_AAC_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_AAC_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_AAC_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_AC3_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_AC3_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_AC3_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_ATMOS_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_ATMOS_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_ATMOS_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_DOLBY_DIGITAL_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_DOLBY_DIGITAL_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_DOLBY_DIGITAL_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_DOLBY_DIGITAL_PLUS_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_DOLBY_DIGITAL_PLUS_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_DOLBY_DIGITAL_PLUS_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_DTS_LOSSY_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_DTS_LOSSY_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_DTS_LOSSY_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_DTS_LOSSLESS_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_DTS_LOSSLESS_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_DTS_LOSSLESS_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_EAC3_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_EAC3_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_EAC3_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_FLAC_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_FLAC_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_FLAC_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_MONO_FETCH=false
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_MONO_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_MONO_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_MP3_FETCH=false
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_MP3_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_MP3_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_STEREO_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_STEREO_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_STEREO_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_SURROUND_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_SURROUND_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_SURROUND_RANK=0
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_TRUEHD_FETCH=true
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_TRUEHD_USE_CUSTOM_RANK=false
      - RIVEN_RANKING_CUSTOM_RANKS_AUDIO_TRUEHD_RANK=0
    healthcheck:
      test: ["CMD-SHELL", "curl -s http://127.0.0.1:8080 >/dev/null || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 10
    labels:
      traefik.enable: "true"
      traefik.http.routers.riven.rule: 'Host(`riven-backend.${DOMAIN}`) || Host(`riven-backend.${TS_HOSTNAME}.${DOMAIN}`)'
      traefik.http.services.riven.loadbalancer.server.port: 8080
      homepage.group: Media Management
      homepage.name: Riven
      homepage.icon: riven.png
      homepage.href: 'https://riven.${DOMAIN}/'
      homepage.description: 'A media request system for Plex/Jellyfin.'
    cpu_shares: 10
    mem_reservation: 20M
    deploy:
      resources:
        limits:
          cpus: 1
          memory: 1G
        reservations:
          cpus: 0.5
          memory: 20M
    restart: always
  riven-db:
    image: 'postgres:16.3-alpine3.20'
    container_name: riven-db
    hostname: riven-db
    extra_hosts:
      - 'host.docker.internal:host-gateway'
    networks:
      - publicnet
    volumes:
      - '${CONFIG_PATH:-./configs}/riven/pgdata:/var/lib/postgresql/data/pgdata'
    environment:
      PGDATA: /var/lib/postgresql/data/pgdata
      POSTGRES_USER: '${RIVEN_DB_USER:-postgres}'
      POSTGRES_PASSWORD: '${RIVEN_DB_PASSWORD:-postgres}'
      POSTGRES_DB: '${RIVEN_DB_NAME:-riven}'
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5
    cpu_shares: 10
    mem_reservation: 6M
    deploy:
      resources:
        reservations:
          cpus: 0
          memory: 6M
        limits:
          cpus: 1
          memory: 4G
    restart: always
  zilean:
    profiles:
      - optional
    depends_on:
      riven-db:
        condition: service_healthy
    image: 'ipromknight/zilean:latest'
    container_name: zilean
    hostname: zilean
    extra_hosts:
      - 'host.docker.internal:host-gateway'
    networks:
      - publicnet
    ports:
      - '8181:8181'
    volumes:
      - '${CONFIG_PATH:-./configs}/zilean/data:/app/data'
      - '${CONFIG_PATH:-./configs}/zilean/tmp:/tmp'
    environment:
      Zilean__Database__ConnectionString: Host=riven-db;Port=5432;Database=zilean;Username=postgres;Password=postgres
    healthcheck:
      test: ["CMD-SHELL", "curl --connect-timeout 10 --silent --show-error --fail http://localhost:8181/healthchecks/ping"]
      timeout: 60s
      interval: 30s
      retries: 10
    restart: unless-stopped
  rclone-zurg:
    depends_on:
      rclone:
        condition: service_healthy
    image: 'ghcr.io/coanghel/rclone-docker-automount/rclone-init:latest'
    container_name: rclone-zurg
    cap_add:
      - SYS_ADMIN
    devices:
      - '/dev/fuse:/dev/fuse'
    security_opt:
      - 'apparmor:unconfined'
    privileged: true
    configs:
      - source: rclone-mounts.json
        target: /app/mounts.json
    volumes:
      - '${ZURG_MOUNT_PATH:-/mnt/remote/zurg}:${ZURG_MOUNT_PATH:-/mnt/remote/zurg}:rshared'
    environment:
      RCLONE_USERNAME: '${RCLONE_USER:?}'
      RCLONE_PASSWORD: '${RCLONE_PASS:?}'
      RCLONE_PORT: '${RCLONE_PORT:-5572}'
      RCLONE_CONFIG_PATH: /config/rclone/rclone.conf
    healthcheck:
      test: ["CMD-SHELL", "mountpoint -q ${ZURG_MOUNT_PATH:-/mnt/remote/zurg}"]
      interval: 5s
      timeout: 3s
      retries: 2
      start_period: 10s
    restart: no
  homer:
    # 🔹🔹 Homer Dashboard 🔹🔹
    image: docker.io/b4bz/homer:latest
    container_name: homer
    hostname: homer
    extra_hosts:
      - host.docker.internal:host-gateway
    volumes:
      - '${CONFIG_PATH:-./configs}/homer/assets:/www/assets'
    configs:
      - source: homer-config.yml
        target: /www/assets/config.yml
    environment:
      TZ: ${TZ:-America/Chicago}
      INIT_ASSETS: 1
    labels:
      traefik.enable: true
      traefik.http.routers.homer.rule: 'Host(`homer.${DOMAIN}`) || Host(`homer.${TS_HOSTNAME}.${DOMAIN}`)'
      traefik.http.services.homer.loadbalancer.server.port: 8080
      homepage.group: Dashboards
      homepage.name: Homer
      homepage.icon: http://127.0.0.1:8080/assets/icons/pwa-192x192.png
      homepage.href: https://homer.${DOMAIN}/
      homepage.description: Static homepage dashboard
    cpu_shares: 10
    mem_reservation: 6M
    mem_limit: 128M
    deploy:
      resources:
        reservations:
          cpus: 0.01
          memory: 6M
        limits:
          cpus: 0.1
          memory: 128M
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://127.0.0.1:8080 || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    restart: always
  plex:
    image: plexinc/pms-docker
    container_name: plex
    hostname: plex
    extra_hosts:
      - 'host.docker.internal:host-gateway'
    networks:
      - publicnet
    secrets:
      - plex-token
    ports:
      - '1900:1900/udp'
      - '8324:8324/tcp'
      - '32400:32400/tcp'
      - '32410:32410/udp'
      - '32412:32412/udp'
      - '32413:32413/udp'
      - '32414:32414/udp'
      - '32469:32469/tcp'
    volumes:
      - '${CONFIG_PATH:-./configs}/plex:/config'
      - '${CONFIG_PATH:-./configs}/plex/config:/config'
      - '${CONFIG_PATH:-./configs}/plex/config/osx-config:/config/Library/Application Support/Plex Media Server'
      - '/dev/shm:/dev/shm'
      - '/mnt/local/transcodes/plex:/transcode'
      - '/mnt/symlinks:/mnt/symlinks'
      - '${ZURG_MOUNT_PATH:-/mnt/remote/zurg}:${ZURG_MOUNT_PATH:-/mnt/remote/zurg}:rshared'
    environment:
      PLEX_CLAIM: '${PLEX_CLAIM:?}'
      PLEX_TOKEN_FILE: /run/secrets/plex-token
      ADVERTISE_IP: 'https://plex.${DOMAIN}:443'
      EMAIL_TO: '${EMAIL_TO:-bolabaden.duckdns@gmail.com}'
      SMTP_FROM: 'transcode-killer@${DOMAIN}'
      SMTP_PORT: '${SMTP_PORT:-587}'
      WAIT_FOR_MOUNT_PATHS: '${ZURG_MOUNT_PATH:-/mnt/remote/zurg}'
      WAIT_FOR_URLS: '${WAIT_FOR_URLS:-http://zurg:9999/http/version.txt}'
    labels:
      traefik.enable: "true"
      traefik.http.routers.plex.rule: 'Host(`plex.${DOMAIN}`) || Host(`plex.${TS_HOSTNAME}.${DOMAIN}`)'
      traefik.http.services.plex.loadbalancer.server.port: 32400
      homepage.group: 'Media Streaming'
      homepage.name: 'Plex Media Server'
      homepage.icon: plex.png
      homepage.href: 'https://plex.${DOMAIN}/'
      homepage.description: 'Stream your movies, TV shows, music, and photos to any device, providing a centralized media hub for all your content.'
      homepage.weight: 4
      homepage.widget.type: plex
      homepage.widget.url: 'https://plex.${DOMAIN}'
      homepage.widget.key: '${PLEX_TOKEN}'
    cpu_shares: 10
    mem_reservation: 2G
    deploy:
      resources:
        reservations:
          cpus: 0.5
          memory: 2G
        limits:
          cpus: 2.5
          memory: 4G
    healthcheck:
      test: ["CMD-SHELL", "curl --connect-timeout 15 --silent --show-error --fail http://127.0.0.1:32400/identity || exit 1"]
      interval: 1m
      timeout: 15s
      retries: 3
      start_period: 1m
    restart: always
  overseerr:
    # 🔹🔹 Overseerr 🔹🔹
    depends_on:
      plex:
        condition: service_healthy
    image: docker.io/linuxserver/overseerr
    container_name: overseerr
    hostname: overseerr
    extra_hosts:
      - host.docker.internal:host-gateway
    volumes:
      - '${CONFIG_PATH:-./configs}/overseerr/config:/config'
    environment:
      TZ: ${TZ:-America/Chicago}
      OVERSEERR_API_KEY: ${OVERSEERR_API_KEY:-}
    labels:
      traefik.enable: "true"
      traefik.http.routers.overseerr.rule: 'Host(`overseerr.${DOMAIN}`) || Host(`overseerr.${TS_HOSTNAME}.${DOMAIN}`)'
      traefik.http.services.overseerr.loadbalancer.server.port: 3000
      homepage.group: Media Requests
      homepage.name: Overseerr Requests
      homepage.icon: overseerr.png
      homepage.href: https://overseerr.${DOMAIN}/
      homepage.description: Allows users to request movies and TV shows, integrating with your media server for easy content management.
      homepage.weight: 3
      homepage.widget.type: overseerr
      homepage.widget.url: https://overseerr.${DOMAIN}
      homepage.widget.key: ${OVERSEERR_API_KEY:?}
    cpu_shares: 10
    mem_reservation: 175M
    deploy:
      resources:
        reservations:
          cpus: 0
          memory: 175M
        limits:
          cpus: 2
          memory: 2G
    restart: always
  maintainerr:
    # 🔹🔹 Maintainerr 🔹🔹  https://docs.maintainerr.info/latest/Works/
    # Looks and smells like Overseerr, does the opposite. Maintenance tool for the Plex ecosystem
    image: ghcr.io/jorenn92/maintainerr:latest
    container_name: maintainerr
    hostname: maintainerr
    extra_hosts:
      - host.docker.internal:host-gateway
    expose:
      - ${MAINTAINERR_API_PORT:-3002}
      - ${MAINTAINERR_UI_PORT:-6246}
    ports:
      - ${MAINTAINERR_API_PORT:-3002}:${MAINTAINERR_API_PORT:-3002}
    volumes:
      - '${CONFIG_PATH:-./configs}/maintainerr/data:/opt/data'
      - '/mnt:/mnt'
    environment:
      API_PORT: "${MAINTAINERR_API_PORT:-3002}"
      DEBUG: "false"
      NODE_ENV: "production"
      UI_HOSTNAME: "0.0.0.0"  # "0.0.0.0" for IPv4, "::" for IPv6
      UI_PORT: "${MAINTAINERR_UI_PORT:-6246}"  # Default 6246.
      UV_USE_IO_URING: "0"  # Temporary workaround for https://github.com/libuv/libuv/pull/4141
    labels:
      traefik.enable: "true"
      traefik.http.routers.maintainerr-api.service: maintainerr-api
      traefik.http.routers.maintainerr-api.rule: 'Host(`maintainerr-api.${DOMAIN}`) || Host(`maintainerr-api.${TS_HOSTNAME}.${DOMAIN}`)'
      traefik.http.services.maintainerr-api.loadbalancer.server.port: ${MAINTAINERR_API_PORT:-3002}
      traefik.http.routers.maintainerr.service: maintainerr
      traefik.http.routers.maintainerr.rule: 'Host(`maintainerr.${DOMAIN}`) || Host(`maintainerr.${TS_HOSTNAME}.${DOMAIN}`)'
      traefik.http.services.maintainerr.loadbalancer.server.port: ${MAINTAINERR_UI_PORT:-6246}
      homepage.group: Media Server Management
      homepage.name: Maintainerr
      homepage.icon: maintainerr.png
      homepage.href: https://maintainerr.${DOMAIN}/
      homepage.description: A comprehensive tool for monitoring and managing your server, providing insights and tools to keep everything running smoothly.
    restart: always
  tautulli:
    # 🔹🔹 Tautulli 🔹🔹
    image: ghcr.io/tautulli/tautulli:latest
    container_name: tautulli
    hostname: ${TAUTULLI_HOSTNAME:-tautulli}
    extra_hosts:
      - host.docker.internal:host-gateway
    volumes:
      - '${CONFIG_PATH:-./configs}/tautulli:/config'
    environment:
      TZ: ${TZ:-America/Chicago}
      TAUTULLI_API_KEY: ${TAUTULLI_API_KEY:?}
    labels:
      traefik.enable: "true"
      traefik.http.routers.tautulli.rule: 'Host(`tautulli.${DOMAIN}`) || Host(`tautulli.${TS_HOSTNAME}.${DOMAIN}`)'
      traefik.http.services.tautulli.loadbalancer.server.port: 8181
      homepage.group: Media Maintenance
      homepage.name: Tautulli
      homepage.icon: tautulli.png
      homepage.href: https://tautulli.${DOMAIN}/
      homepage.description: Tautulli is a web interface for Plex Media Server.
      homepage.weight: 6
      homepage.widget.type: tautulli
      homepage.widget.url: http://tautulli:8181
      homepage.widget.key: ${TAUTULLI_API_KEY:?}
    cpu_shares: 10
    mem_reservation: 64M
    deploy:
      resources:
        reservations:
          cpus: 0
          memory: 64M
        limits:
          cpus: 1
          memory: 1G
    restart: always
  realdebrid-account-monitor:
    # 🔹🔹 RealDebrid Account Monitor 🔹🔹
    # This is a service that allows you to monitor your real debrid accounts and traffic.
    build:
      context: .
      dockerfile_inline: |
        FROM python:3.13-slim
        WORKDIR /app
        RUN pip install croniter python-dotenv requests schedule
        CMD ["python3", "main.py"]
    container_name: realdebrid-account-monitor
    configs:
      - source: realdebrid-account-monitor-main.py
        target: /app/main.py
    volumes:
      - '${CONFIG_PATH:-./configs}/realdebrid-account-monitor:/app/data'
    environment:
      TOKENS: '["${REALDEBRID_API_KEY:?}","${REALDEBRID_API_KEY2:-}"]'  # A list of your real debrid api keys. e.g. ["key1", "key2"]  You can get your api key from https://real-debrid.com/apitoken
      CRON_SCHEDULE: '0 * * * *'  # How often to check the accounts for traffic. This is a cron schedule.  e.g. every hour: 0 * * * *
      TZ: ${TZ:-America/Chicago}  # The timezone to use for the cron schedule.
    restart: always
  wizarr:
    image: 'ghcr.io/wizarrrr/wizarr:latest'
    container_name: wizarr
    hostname: wizarr
    extra_hosts:
      - 'host.docker.internal:host-gateway'
    networks:
      - publicnet
    secrets:
      - plex-token
    expose:
      - 5690
    volumes:
      - '${CONFIG_PATH:-./configs}/wizarr/database:/data/database'
      - '${CONFIG_PATH:-./configs}/wizarr/config:/config'
    environment:
      APP_URL: 'http://wizarr:5690'
      DISABLE_BUILTIN_AUTH: '${WIZARR_DISABLE_BUILTIN_AUTH:-true}'
      PLEX_URL: 'http://plex:32400'
      PLEX_TOKEN_FILE: /run/secrets/plex-token
    labels:
      traefik.enable: "true"
      traefik.http.routers.wizarr.rule: 'Host(`wizarr.${DOMAIN}`) || Host(`wizarr.${TS_HOSTNAME}.${DOMAIN}`)'
      traefik.http.services.wizarr.loadbalancer.server.port: 5690
      homepage.group: 'Media Management'
      homepage.name: Wizarr
      homepage.icon: 'http://127.0.0.1:5690/static/wizarr-logo.png'
      homepage.href: 'https://wizarr.${DOMAIN}/'
      homepage.description: 'User invitation and management system for Plex'
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://127.0.0.1:5690/static/wizarr-logo.png || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    restart: always
  zurg:
    depends_on:
      rclone-zurg:
        condition: service_healthy
    image: 'ghcr.io/debridmediamanager/zurg-testing:latest'
    container_name: zurg
    hostname: zurg
    extra_hosts:
      - 'host.docker.internal:host-gateway'
    networks:
      publicnet: {}
      warp-nat-net:
        gw_priority: 1
    volumes:
      - '${CONFIG_PATH:-./configs}/zurg/app/data:/app/data'
    configs:
      - source: zurg-config.yml
        target: /app/config.yml
        mode: '0775'
      - source: zurg-cli_debrid_update.sh
        target: /app/plex_update.sh
        mode: '0775'
    environment:
      K8S_APP_NAME: zurg
      ZURG_LOG_LEVEL: 'info'
      REALDEBRID_API_KEY: '${REALDEBRID_API_KEY:?}'
      REALDEBRID_TOKEN: '${REALDEBRID_TOKEN:?}'
    labels:
      traefik.enable: "true"
      traefik.http.routers.zurg.rule: 'Host(`zurg.${DOMAIN}`) || Host(`zurg.${TS_HOSTNAME}.${DOMAIN}`)'
      traefik.http.services.zurg.loadbalancer.server.port: 9999
      homepage.group: 'Download Clients'
      homepage.name: Zurg
      homepage.icon: zurg.png
      homepage.href: 'https://zurg.${DOMAIN}/'
      homepage.description: 'Real-Debrid WebDAV proxy for seamless streaming'
    cpu_shares: 10
    mem_reservation: 32M
    deploy:
      resources:
        reservations:
          cpus: 0
          memory: 32M
        limits:
          cpus: 1
          memory: 2G
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://127.0.0.1:9999/http/version.txt || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    restart: always
